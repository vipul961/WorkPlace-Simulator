#pragma warning(disable: 4996)

#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <unordered_map>
#include <condition_variable>
#include <atomic>


using namespace std;
using namespace chrono;
using namespace literals::chrono_literals;//s, h, min, ms, us, ns

class Timer {
public:
    chrono::system_clock::time_point Begin;
    chrono::system_clock::time_point End;
    chrono::system_clock::duration RunTime;

    Timer() {//constructor
        Begin = chrono::system_clock::now();
    }

    ~Timer() {
        End = chrono::system_clock::now();
        RunTime = End - Begin;
        cout << "Run Time is " << chrono::duration_cast<chrono::milliseconds>(RunTime).count() << "ms" << endl;
    }
    // hours, microseconds, milliseconds, minutes, nanoseconds, seconds can be used for units
};

mutex m1, m2, m3;
condition_variable cv_buff_part, cv_buff_product;
const int MaxTimePart{30000}, MaxTimeProduct{28000};
int maxIteration = 5;
vector<int> maxBufferState = {7, 6, 5, 5, 4};
vector<int> currentBufferState(5, 0);
vector<int> manufactureWait = {500, 500, 600, 600, 700};
vector<int> bufferWait = {200, 200, 300, 300, 400};
vector<int> assemblyWait = {600, 600, 700, 700, 800};
atomic_int totalProducts;

vector<int> ProduceLoadOrder(vector<int> unloadedOrders);

vector<int> ProducePickupOrder(vector<int> localState);

bool CheckBufferStatePart(vector<int> &currentBufferState, vector<int> &loadOrder);

void LoadBufferState(int id, vector<int> &loadOrder, int &iteration);

bool CheckBufferStateProduct(vector<int> &currentBufferState, vector<int> &pickUpOrder);

void UnloadBufferState(int id, vector<int> &pickUpOrder, int &iteration, vector<int> &cartState, vector<int> &localState);

void ProductWorker(int id);

void PartWorker(int id);

void AssembleParts(vector<int>& cartState, vector<int>&localState);

int main() {


    const int m = 20, n = 16; //m: number of Part Workers
    //n: number of Product Workers
    //Different numbers might be used during grading.
    vector<thread> PartW, ProductW;
    {
        Timer TT;
        for (int i = 0; i < m; ++i) {

            PartW.emplace_back(PartWorker, i + 1);
        }
        for (int i = 0; i < n; ++i) {
            ProductW.emplace_back(ProductWorker, i + 1);
        }
        for (auto &i: PartW) i.join();
        for (auto &i: ProductW) i.join();
    }
    cout<<"Final value of total products assembled is: "<<totalProducts<<endl;
    cout << "Finish!" << endl;

    return 0;
}

vector<int> ProduceLoadOrder(vector<int> unloadedOrders) {

    vector<int> loadOrder(unloadedOrders);
    int fixedOrderItemLimit = 6;
    int presentOrderItems = 0;
    for (auto i: unloadedOrders) {
        presentOrderItems += i;
    }

    int remainingParts = fixedOrderItemLimit - presentOrderItems;
    while (remainingParts != 0) {
        srand(system_clock::now().time_since_epoch().count());
        int randNumParts = rand() % (remainingParts);
        int partType = rand() % 5;
        this_thread::sleep_for(randNumParts * microseconds(manufactureWait[partType]));
        loadOrder[partType] += ++randNumParts;
        remainingParts -= randNumParts;
    }
    return loadOrder;
}

vector<int> ProducePickupOrder(vector<int> localState) {
    vector<int> pickUpOrder(localState);
    int fixedOrderItemLimit = 5;
    int presentOrderItems = 0;
    unordered_map<int, int> partNum;
    for (int i = 0; i < localState.size(); i++) {
        presentOrderItems += localState[i];
        if (localState[i] > 0)partNum[i]++;
    }

    int remainingParts = fixedOrderItemLimit - presentOrderItems;
    while (remainingParts != 0) {
        srand(system_clock::now().time_since_epoch().count());
        int randNumParts = rand() % (remainingParts);
        int partType = rand() % 5;
        if ((partNum.size() <= 3 && partNum.find(partType) != partNum.end()) || partNum.size() < 3 ) {
            if ((partNum.size() == 3 || partNum.size() == 2) && partNum.find(partType) != partNum.end()) {
                pickUpOrder[partType] += ++randNumParts;
                remainingParts -= randNumParts;
                this_thread::sleep_for(microseconds(manufactureWait[partType]) * randNumParts);
            } else if (partNum.size() == 2 && partNum.find(partType) == partNum.end()) {
                partNum[partType]++;
                pickUpOrder[partType] += ++randNumParts;
                remainingParts -= randNumParts;
                this_thread::sleep_for(microseconds(manufactureWait[partType]) * randNumParts);
            } else if (localState[partType] + randNumParts + 1 != fixedOrderItemLimit) {
                pickUpOrder[partType] += ++randNumParts;
                remainingParts -= randNumParts;
                this_thread::sleep_for(microseconds(manufactureWait[partType]) * randNumParts);
            }
        }
    }

    for(int i=0;i<pickUpOrder.size();i++){
        pickUpOrder[i] = pickUpOrder[i]-localState[i];
    }
    return pickUpOrder;
}

bool CheckBufferStatePart(vector<int> &currentBufferState, vector<int> &loadOrder) {
    for (int i = 0; i < currentBufferState.size(); ++i) {
        if (currentBufferState[i] < maxBufferState[i] && loadOrder[i] > 0) {
            return true;
        }
    }
    return false;
}

bool checkOrder(vector<int> &order) {
    for (auto i: order) {
        if (i > 0)return true;
    }
    return false;
}

void LoadBufferState(int id, vector<int> &loadOrder, int &iteration) {
    loadOrder = ProduceLoadOrder(loadOrder);
    auto deadline = steady_clock::now() + microseconds(MaxTimePart);
    auto start_time = steady_clock::now();
    steady_clock::duration total_wait_time = microseconds(0);
    while (checkOrder(loadOrder)) {
        unique_lock UL1(m1);

        if (cv_buff_part.wait_until(UL1, deadline, [&loadOrder]() {
            return CheckBufferStatePart(currentBufferState, loadOrder);
        })) {
            auto end_time = steady_clock::now();
            total_wait_time += end_time - start_time;
            start_time = steady_clock::now();
            {

                cout << endl;
                cout << "Iteration for part worker: " << id << " is : " << iteration + 1 << endl;
                cout << "part worker id " << id;
                cout << " loadOrder value: ";
                for (auto i: loadOrder) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "CurrentBufferState: ";
                for (auto i: currentBufferState) {
                    cout << i << " ";
                }
                cout << endl;
            }

            for (int i = 0; i < currentBufferState.size(); i++) {
                int remainingSpace = maxBufferState[i] - currentBufferState[i];
                if (remainingSpace > 0 && loadOrder[i] > 0) {
                    int amount_to_load = min(remainingSpace, loadOrder[i]);
                    this_thread::sleep_for(microseconds(bufferWait[i]) * amount_to_load);
                    currentBufferState[i] += amount_to_load;
                    loadOrder[i] -= amount_to_load;
                }
            }
            {


                cout << "UpdatedBufferState: ";
                for (auto i: currentBufferState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "loadOrder Updated ";
                for (auto i: loadOrder) {
                    cout << i << " ";
                }
                cout << endl;

                cout << "Thread " << id << " waited for " << duration_cast<microseconds>(total_wait_time).count()
                     << "us " << endl;
            }
            cv_buff_part.notify_all();
            cv_buff_product.notify_all();
        } else {
            auto end_time = steady_clock::now();
            total_wait_time += end_time - start_time;
            {

                cout<<endl;
                cout << "Timeout Occurred for part worker: " << id << endl;
                cout << "Thread for part: " << id << " waited for " << duration_cast<microseconds>(total_wait_time).count()
                     << "us before timing out" << endl;
            }
            {

                cout << "Iteration for part worker: " << id << " is : " << iteration + 1 << endl;
                cout << "part worker id " << id;
                cout << " loadOrder value: ";
                for (auto i: loadOrder) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "CurrentBufferState: ";
                for (auto i: currentBufferState) {
                    cout << i << " ";
                }
                cout << endl;
            }
            cv_buff_part.notify_all();
            cv_buff_product.notify_all();
            if (iteration < maxIteration-1) {
                UL1.unlock();
                LoadBufferState(id, loadOrder, ++iteration);
            }
            return;
        }
    }
    cv_buff_part.notify_all();
    cv_buff_product.notify_all();
    {
        cout << "Thread for part: " << id << " completed iteration " << iteration + 1 << " with a total wait time of "
             << duration_cast<microseconds>(total_wait_time).count() << "us" << endl;
    }

    if (iteration < maxIteration - 1) {
        //UL1.unlock();
        LoadBufferState(id, loadOrder, ++iteration);
    } else {
        cout << "Cannot update again: part worker : " << id << endl;
    }
}


bool CheckBufferStateProduct(vector<int> &currentBufferState, vector<int> &pickUpOrder) {
    for (int i = 0; i < currentBufferState.size(); ++i) {
        if (currentBufferState[i] > 0 && pickUpOrder[i] > 0) {
            return true;
        }
    }
    return false;
}

void UnloadBufferState(int id, vector<int> &pickUpOrder, int &iteration,vector<int> &cartState,vector<int> &localState) {

    pickUpOrder = ProducePickupOrder(localState);
    auto deadline = steady_clock::now() + microseconds(MaxTimeProduct);
    auto start_time = steady_clock::now();

    steady_clock::duration total_wait_time = microseconds(0);
    while (checkOrder(pickUpOrder)) {
        unique_lock UL1(m1);

        if (cv_buff_part.wait_until(UL1, deadline, [&pickUpOrder]() {
            return CheckBufferStateProduct(currentBufferState, pickUpOrder);
        })) {
            auto end_time = steady_clock::now();
            total_wait_time += end_time - start_time;
            start_time = steady_clock::now();

            {

                cout << endl;
                cout << "Iteration for product worker: " << id << " is : " << iteration + 1 << endl;
                cout << "product worker id " << id;
                cout << " pickUpOrder value: ";
                for (auto i: pickUpOrder) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "CurrentBufferState: ";
                for (auto i: currentBufferState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "Current cartState ";
                for (auto i: cartState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "Current localState ";
                for (auto i: localState) {
                    cout << i << " ";
                }
                cout << endl;
            }
            for (int i = 0; i < currentBufferState.size(); i++) {
                int availableSpace = currentBufferState[i];
                if (availableSpace > 0 && pickUpOrder[i] > 0) {
                    int amount_to_unload = min(availableSpace, pickUpOrder[i]);
                    this_thread::sleep_for(microseconds(bufferWait[i]) * amount_to_unload);
                    currentBufferState[i] -= amount_to_unload;
                    pickUpOrder[i] -= amount_to_unload;
                    cartState[i] += amount_to_unload;
                }
            }
            {

                cout << "UpdatedBufferState: ";
                for (auto i: currentBufferState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "pickUpOrder Updated ";
                for (auto i: pickUpOrder) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "cartState Updated ";
                for (auto i: cartState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "localState Updated ";
                for (auto i: localState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "Thread " << id << " waited for " << duration_cast<microseconds>(total_wait_time).count()
                     << "us" << endl;
            }
            cv_buff_part.notify_all();
            cv_buff_product.notify_all();
        } else {
            auto end_time = steady_clock::now();
            total_wait_time += end_time - start_time;

            {

                cout<<endl;
                cout << "Timeout Occurred for product worker: " << id << endl;
                cout << "Thread for product: " << id << " waited for " << duration_cast<microseconds>(total_wait_time).count()
                     << "us before timing out" << endl;
            }
            {
                for(int i=0;i<cartState.size();i++){
                    localState[i]+=cartState[i];
                    cartState[i]=0;
                }

                cout << "Iteration for product worker: " << id << " is : " << iteration + 1 << endl;
                cout << "product worker id " << id;
                cout << " pickUpOrder value: ";
                for (auto i: pickUpOrder) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "CurrentBufferState: ";
                for (auto i: currentBufferState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "Current cartState ";
                for (auto i: cartState) {
                    cout << i << " ";
                }
                cout << endl;
                cout << "Current localState ";
                for (auto i: localState) {
                    cout << i << " ";
                }
                cout << endl;
            }
            cv_buff_part.notify_all();
            cv_buff_product.notify_all();
            if (iteration < maxIteration - 1) {
                UL1.unlock();
                UnloadBufferState(id, pickUpOrder, ++iteration,cartState,localState);
            }
            return;
        }
    }

    {

        cout << "Thread for product: " << id << " completed iteration " << iteration + 1 << " with a total wait time of "
             << duration_cast<microseconds>(total_wait_time).count() << "ms" << endl;
    }
    AssembleParts(cartState,localState);
    totalProducts++;
    cv_buff_part.notify_all();
    cv_buff_product.notify_all();
    if (iteration < maxIteration - 1) {
        {

            cout << "Total Products assembled: " << totalProducts << endl;
        }
        //UL1.unlock();
        UnloadBufferState(id, pickUpOrder, ++iteration,cartState,localState);
    } else {


        cout << "Cannot update again: product worker : " << id << endl;
    }

}

void AssembleParts(vector<int> &cartState,vector<int>&localState) {
    for(int i=0;i<cartState.size();i++){
        this_thread::sleep_for(microseconds(assemblyWait[i]) * (cartState[i]+localState[i]));
        cartState[i]=0;
        localState[i]=0;
    }
}


void ProductWorker(int id) {

    vector<int> pickUpOrder(5),cartState(5),localState(5);
    int iteration = 0;
    UnloadBufferState(id, pickUpOrder, iteration,cartState,localState);

}

void PartWorker(int id) {

    vector<int> loadOrder(5);
    int iteration = 0;
    LoadBufferState(id, loadOrder, iteration);

}